//! Typst form generation module
//!
//! This module provides functionality to generate Typst (.typ) markup files
//! from wizard interviews. Unlike the typst_backend which generates PDFs,
//! this generates the raw Typst markup as a string.

use crate::interview::{Interview, Question, QuestionKind};

/// Generate Typst markup from an interview
pub fn generate_typst_form(interview: &Interview, title: Option<&str>) -> String {
    let mut markup = String::new();

    // Document setup - clean and minimal
    markup.push_str("// Generated by derive-wizard\n\n");

    markup.push_str("#set page(\n");
    markup.push_str("  paper: \"a4\",\n");
    markup.push_str("  margin: (x: 2.5cm, y: 2cm),\n");
    markup.push_str(")\n\n");

    markup.push_str("#set text(font: \"Liberation Serif\", size: 11pt)\n");
    markup.push_str("#set par(justify: false, leading: 0.5em, spacing: 0.5em)\n");
    markup.push_str("#show heading: set text(weight: \"bold\")\n\n");

    // Title
    if let Some(title) = title {
        markup.push_str("#align(center)[\n");
        markup.push_str(&format!(
            "  #text(size: 16pt, weight: \"bold\")[{}]\n",
            escape_typst_text(title)
        ));
        markup.push_str("]\n\n");
    }

    // Prelude
    if let Some(prelude) = &interview.prelude {
        markup.push_str(&format!(
            "#text(size: 10pt, style: \"italic\")[{}]\n\n",
            escape_typst_text(prelude)
        ));
    }

    // Generate form fields for each question
    for question in &interview.sections {
        generate_question_markup(&mut markup, question);
    }

    // Epilogue
    if let Some(epilogue) = &interview.epilogue {
        markup.push_str(&format!(
            "\n#text(size: 10pt, style: \"italic\")[{}]\n",
            escape_typst_text(epilogue)
        ));
    }

    markup
}

fn generate_question_markup(markup: &mut String, question: &Question) {
    // Skip questions with assumptions (they're pre-filled)
    if question.assumed().is_some() {
        return;
    }

    match question.kind() {
        QuestionKind::Input(_) => {
            generate_text_input(markup, question);
        }
        QuestionKind::Multiline(_) => {
            generate_multiline_input(markup, question);
        }
        QuestionKind::Masked(_) => {
            generate_text_input(markup, question);
        }
        QuestionKind::Int(int_q) => {
            generate_numeric_input(markup, question, int_q.min, int_q.max);
        }
        QuestionKind::Float(float_q) => {
            generate_numeric_input(markup, question, float_q.min, float_q.max);
        }
        QuestionKind::Confirm(_) => {
            generate_confirm(markup, question);
        }
        QuestionKind::Sequence(questions) => {
            // Check if this is an enum alternatives sequence
            let is_enum_alternatives = !questions.is_empty()
                && questions
                    .iter()
                    .all(|q| matches!(q.kind(), QuestionKind::Alternative(_, _)));

            if is_enum_alternatives {
                generate_enum(markup, question, questions);
            } else {
                // Regular sequence (struct fields)
                generate_struct_fields(markup, question, questions);
            }
        }
        QuestionKind::Alternative(_, alternatives) => {
            // This shouldn't normally be reached as alternatives are wrapped in sequences
            for alt in alternatives {
                generate_question_markup(markup, alt);
            }
        }
    }
}

fn generate_text_input(markup: &mut String, question: &Question) {
    markup.push_str("#block(spacing: 0.4em)[\n");
    markup.push_str("  #grid(\n");
    markup.push_str("    columns: (auto, 1fr),\n");
    markup.push_str("    column-gutter: 0.6em,\n");
    markup.push_str("    align: (left + horizon, left + horizon),\n");
    let prompt = escape_typst_text(question.prompt());
    let prompt_with_colon = if prompt.ends_with(':') || prompt.ends_with('?') {
        prompt
    } else {
        format!("{}:", prompt)
    };
    markup.push_str(&format!("    text(size: 10pt)[{}],\n", prompt_with_colon));
    markup.push_str("    box(\n");
    markup.push_str("      width: 100%,\n");
    markup.push_str("      height: 1.5em,\n");
    markup.push_str("      stroke: (bottom: 0.5pt + black),\n");
    markup.push_str("      inset: (x: 2pt, bottom: 1pt),\n");
    markup.push_str("    )[]\n");
    markup.push_str("  )\n");
    markup.push_str("]\n\n");
}

fn generate_multiline_input(markup: &mut String, question: &Question) {
    markup.push_str("#block(spacing: 0.4em)[\n");
    let prompt = escape_typst_text(question.prompt());
    let prompt_with_colon = if prompt.ends_with(':') || prompt.ends_with('?') {
        prompt
    } else {
        format!("{}:", prompt)
    };
    markup.push_str(&format!("  #text(size: 10pt)[{}]\n", prompt_with_colon));
    markup.push_str("  #v(0.15em)\n");
    markup.push_str("  #box(\n");
    markup.push_str("    width: 100%,\n");
    markup.push_str("    height: 4em,\n");
    markup.push_str("    stroke: 0.5pt + black,\n");
    markup.push_str("    inset: 3pt,\n");
    markup.push_str("  )[]\n");
    markup.push_str("]\n\n");
}

fn generate_numeric_input<T: std::fmt::Display>(
    markup: &mut String,
    question: &Question,
    min: Option<T>,
    max: Option<T>,
) {
    let constraints = match (min, max) {
        (Some(min), Some(max)) => format!(" ({} â€“ {})", min, max),
        (Some(min), None) => format!(" (min: {})", min),
        (None, Some(max)) => format!(" (max: {})", max),
        _ => String::new(),
    };

    markup.push_str("#block(spacing: 0.4em)[\n");
    markup.push_str("  #grid(\n");
    markup.push_str("    columns: (auto, 1fr),\n");
    markup.push_str("    column-gutter: 0.6em,\n");
    markup.push_str("    align: (left + horizon, left + horizon),\n");
    let prompt = escape_typst_text(question.prompt());
    let prompt_with_colon = if prompt.ends_with(':') || prompt.ends_with('?') {
        prompt
    } else {
        format!("{}:", prompt)
    };
    markup.push_str(&format!(
        "    text(size: 10pt)[{}] + text(size: 8pt)[{}],\n",
        prompt_with_colon, constraints
    ));
    markup.push_str("    box(\n");
    markup.push_str("      width: 100%,\n");
    markup.push_str("      height: 1.5em,\n");
    markup.push_str("      stroke: (bottom: 0.5pt + black),\n");
    markup.push_str("      inset: (x: 2pt, bottom: 1pt),\n");
    markup.push_str("    )[]\n");
    markup.push_str("  )\n");
    markup.push_str("]\n\n");
}

fn generate_confirm(markup: &mut String, question: &Question) {
    markup.push_str("#block(spacing: 0.4em)[\n");
    let prompt = escape_typst_text(question.prompt());
    let prompt_with_colon = if prompt.ends_with(':') || prompt.ends_with('?') {
        prompt
    } else {
        format!("{}:", prompt)
    };
    markup.push_str(&format!("  #text(size: 10pt)[{}]\n", prompt_with_colon));
    markup.push_str("  #v(0.15em)\n");
    markup.push_str("  #grid(\n");
    markup.push_str("    columns: (auto, auto, 1.5em, auto, auto),\n");
    markup.push_str("    gutter: 0.4em,\n");
    markup.push_str("    align: horizon,\n");
    markup.push_str("    box(width: 1.2em, height: 1.2em, stroke: 0.5pt + black)[],\n");
    markup.push_str("    text(size: 10pt)[Yes],\n");
    markup.push_str("    [],\n");
    markup.push_str("    box(width: 1.2em, height: 1.2em, stroke: 0.5pt + black)[],\n");
    markup.push_str("    text(size: 10pt)[No],\n");
    markup.push_str("  )\n");
    markup.push_str("]\n\n");
}

fn generate_enum(markup: &mut String, question: &Question, variants: &[Question]) {
    markup.push_str("#block(spacing: 0.4em)[\n");
    let prompt = escape_typst_text(question.prompt());
    let prompt_with_colon = if prompt.ends_with(':') || prompt.ends_with('?') {
        prompt
    } else {
        format!("{}:", prompt)
    };
    markup.push_str(&format!("  #text(size: 10pt)[{}]\n", prompt_with_colon));
    markup.push_str("  #v(0.15em)\n");

    for (idx, variant) in variants.iter().enumerate() {
        if idx > 0 {
            markup.push_str("  #v(0.2em)\n");
        }

        // Radio button
        markup.push_str("  #grid(\n");
        markup.push_str("    columns: (auto, 1fr),\n");
        markup.push_str("    gutter: 0.4em,\n");
        markup.push_str("    align: (left + horizon, left + horizon),\n");
        markup.push_str("    box(\n");
        markup.push_str("      width: 1.2em,\n");
        markup.push_str("      height: 1.2em,\n");
        markup.push_str("      stroke: 0.5pt + black,\n");
        markup.push_str("    )[],\n");
        markup.push_str(&format!(
            "    text(size: 10pt)[{}]\n",
            escape_typst_text(variant.name())
        ));
        markup.push_str("  )\n");

        // If variant has fields, show them indented
        if let QuestionKind::Alternative(_, fields) = variant.kind()
            && !fields.is_empty()
        {
            markup.push_str("  #v(0.2em)\n");
            markup.push_str("  #box(\n");
            markup.push_str("    inset: (left: 1.5em, top: 0.15em, bottom: 0.15em),\n");
            markup.push_str("    width: 100%,\n");
            markup.push_str("  )[\n");
            for field in fields {
                // Don't add extra heading for fields inside enum variants
                match field.kind() {
                    QuestionKind::Sequence(nested_questions) => {
                        // Check if this is a nested enum
                        let is_nested_enum = !nested_questions.is_empty()
                            && nested_questions
                                .iter()
                                .all(|q| matches!(q.kind(), QuestionKind::Alternative(_, _)));

                        if is_nested_enum {
                            // Render as enum without struct heading
                            generate_enum(markup, field, nested_questions);
                        } else {
                            // Render struct fields directly without heading
                            for nested_field in nested_questions {
                                generate_question_markup(markup, nested_field);
                            }
                        }
                    }
                    _ => {
                        generate_question_markup(markup, field);
                    }
                }
            }
            markup.push_str("  ]\n");
        }
    }
    markup.push_str("]\n\n");
}

fn generate_struct_fields(markup: &mut String, question: &Question, fields: &[Question]) {
    // Add a section header for the struct
    markup.push_str("#block(\n");
    markup.push_str("  above: 0.6em,\n");
    markup.push_str("  below: 0.4em,\n");
    markup.push_str(")[\n");
    markup.push_str("  #text(\n");
    markup.push_str("    size: 11pt,\n");
    markup.push_str("    weight: \"bold\",\n");
    markup.push_str("  )[\n");
    markup.push_str(&format!("    {}\n", escape_typst_text(question.prompt())));
    markup.push_str("  ]\n");
    markup.push_str("]\n\n");

    for field in fields {
        generate_question_markup(markup, field);
    }

    markup.push_str("#v(0.3em)\n\n");
}

/// Escape special characters in Typst text
fn escape_typst_text(text: &str) -> String {
    text.replace('\\', "\\\\")
        .replace('[', "\\[")
        .replace(']', "\\]")
        .replace('#', "\\#")
        .replace('*', "\\*")
        .replace('_', "\\_")
        .replace('`', "\\`")
        .replace('@', "\\@")
        .replace('<', "\\<")
        .replace('>', "\\>")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_escape_typst_text() {
        assert_eq!(escape_typst_text("Hello [World]"), "Hello \\[World\\]");
        assert_eq!(escape_typst_text("C:\\path\\file"), "C:\\\\path\\\\file");
        assert_eq!(escape_typst_text("#heading"), "\\#heading");
        assert_eq!(escape_typst_text("*bold*"), "\\*bold\\*");
        assert_eq!(escape_typst_text("user@example.com"), "user\\@example.com");
        assert_eq!(escape_typst_text("<link>"), "\\<link\\>");
    }

    #[test]
    fn test_generate_empty_interview() {
        let interview = Interview {
            sections: vec![],
            prelude: None,
            epilogue: None,
        };

        let markup = generate_typst_form(&interview, None);
        assert!(markup.contains("#set page"));
        assert!(markup.contains("#set text"));
    }

    #[test]
    fn test_generate_with_title() {
        let interview = Interview {
            sections: vec![],
            prelude: None,
            epilogue: None,
        };

        let markup = generate_typst_form(&interview, Some("Test Form"));
        assert!(markup.contains("#set page"));
        assert!(markup.contains("#set text"));
        assert!(markup.contains("Test Form"));
    }
}
